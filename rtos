参考网页：
https://blog.csdn.net/lxl584685501/article/details/46605019?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduend~default-4-46605019.nonecase&utm_term=rtos%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F
https://baike.baidu.com/item/MMU/4542218?fr=aladdin
https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/3883950?fr=aladdin
https://blog.csdn.net/weixin_34019929/article/details/85920153?utm_medium=distribute.pc_relevant.none-task-blog-title-1&spm=1001.2101.3001.4242

四种实时操作系统(RTOS)是：Lynx实时系统公司的LynxOS、QNX软件系统有限公司的QNX以及两种具有代表性的实时Linux--新墨西哥工学院的RT－Linux和堪萨斯大学的KURT－Linux
实时操作系统的特征
　多任务
　有线程优先级
　多种中断级别
 
基本概念
  临界代码段：不论是硬件临界资源，还是软件临界资源，多个进程必须互斥地对它进行访问，中断处理程序和任务都会访问临界段代码，需要用关中断的方法加以保护。
  资源：任何为任务所占用的实体
  共享资源：可以被一个以上任务使用的资源
  任务：也称作一个线程，是一个简单的程序。每个任务被赋予一定的优先级，有它自己的一套CPU寄存器和自己的栈空间
      典型地，每个任务都是一个无限的循环，每个任务都处在以下五个状态下：休眠态，就绪态，运行态，挂起态，被中断态
  任务切换：将正在运行任务的当前状态（CPU寄存器中的全部内容）保存在任务自己的栈区，然后把下一个将要运行的任务的当前状态从该任务的栈中重新装入CPU的寄存器，并开始下一个任务的运行
  内核：负责管理各个任务，为每个任务分配CPU时间，并负责任务之间通讯。分为不可剥夺型内核于可剥夺型内核
  调度：内核的主要职责之一，决定轮到哪个任务运行。一般基于优先级调度法
  
关于优先级的问题
  任务优先级：分为优先级不可改变的静态优先级和优先级可改变的动态优先级
  优先级反转：优先级反转问题是实时系统中出现最多的问题。共享资源的分配可导致优先级低的任务先运行，优先级高的任务后运行。解决的办法是使用“优先级继承”算法来临时改变任务优先级，以遏制优先级反转
    当高优先级任务正等待信号量（此信号量被一个低优先级任务拥有着）的时候，一个介于两个任务优先之间的中等优先级任务开始执行——这就会导致一个高优先级任务
      在等待一个低优先级任务，而低优先级任务却无法执行类似死锁的情形发生,导致介于二者之间的毫无相关任务获得优先执行，浪费优先级高的任务的时间
    优先级继承就是为了解决优先级反转问题而提出的一种优化机制。其大致原理是让低优先级线程在获得同步资源的时候(如果有高优先级的线程也需要使用该同步资源时)，
      临时提升其优先级。以前其能更快的执行并释放同步资源。释放同步资源后再恢复其原来的优先级
      
 互斥
    虽然共享数据区简化了任务之间的信息交换，但是必须保证每个任务在处理共享共享数据时的排他性。使之满足互斥条件的一般方法有：关中断，使用测试并置位指令（TAS），禁止做任务切换，利用信号量
    中断响应时间通常被定义为：
　　中断响应时间=中断延迟时间+保存CPU状态的时间+该内核的ISR进入函数的执行时间[2]
　　中断延迟时间=MAX(关中断的最长时间，最长指令时间) + 开始执行ISR的第一条指令的时间 嵌入式中的ISR指的是中断服务处理，Interrupt Service Routines
  
分时—— 现在流行的PC，服务器都是采用这种运行模式，即把CPU的运行分成若干时间片分别处理不同的运算请求
实时—— 一般用于单片机上，比如电梯的上下控制中，对于按键等动作要求进行实时处理

性能分析：
 任务管理：优先级设置、多任务调度机制和时间确定性
    优先级设置：静态优先级和动态优先级
    多任务调度机制：协调对CPU资源的争夺使用，分为基于优先级抢占式调度（PBP，Priority Based and Preemptive）和时间片轮调度(RR, Round Robin)
     基于优先级抢占调度：CPU分配给处于就绪态的优先级最高的任务，如果此时有优先级更高的任务，则把当前运行任务置于就绪态，调入高优先级任务运行，保证突发事件及时得到处理
     时间片轮调度：让优先级相同的处于就绪态的任务按时间片使用cpu，防止同优先级的某一任务长时间独占CPU
     在一般情况下，嵌入式实时操作系统采用基于优先级抢占式调度与时间片轮转调度相结合的调度机制
 任务及中断间的同步与通信机制
    实时操作系统的功能一般要通过若干任务和中断服务程序共同完成。任务与任务之间、任务与中断间任务及中断服务程序之间必须协调动作，互相配合.
    嵌入式实时操作系统通常是通过信号量Semaphere、互斥信号量Mutex、事件标志Event和异步信号Signal来实现同步，通过消息邮箱MailBox、消息队列Message、管道Pipe和共享内存Share Mem来提供通信服务
 内存管理主要包括：内存分配原则，存储保护和内存分配方式
    内存分配原则包括快速性、可靠性和高效性
    通常在操作系统的内存中既有系统程序也有用户程序，为了使两者都能正常运行，避免程序间相互干扰，需要对内存中的程序和数据进行保护 MMU
    内存分配方式可分为静态分配和动态分配
 中断管理
    是否支持中断嵌套、中断处理机制、中断延时等
 文件系统
 -----------  
    hal_gpt_sw_start_timer_ms 和 xTimerCreate 一个GPT的偏硬件，精度比较好，一个是软件模拟的，精度不高，但是GPT是有使用次数限制。
-----------
xTaskCreate() 创建线程以及优先级，vTaskPrioritySet()修改线程优先级
vTaskDelay() 线程延迟堵塞N个心跳周期，离开堵塞态
vTaskDelayUntil() 线程延迟N个心跳周期后由堵塞态进入就绪态

Cortex-M3 和 M4 内核具有双堆栈指针，MSP 主堆栈指针和 PSP 进程堆栈指针，一旦进入了中断函数以及可能发生的中断嵌套都是用的 MSP 指针，
非FPU（浮点运算单元）的情况下，最大需要保存16个通用寄存器参数到栈中，一般寄存器是4个字节，16*4=64个字节
FPU（浮点运算单元）的情况下，还需额外34个浮点寄存器，（16+34）*4 =200个字节

获取task的运行状态：
 vTaskList---显示当前系统所有task的任务名，任务状态，优先级，剩余栈，任务序号
 vTaskList((char *)&pcWriteBuffer);
 printf("%s\r\n", pcWriteBuffer);
 vTaskGetRunTimeStats---显示任务名，运行次数，cpu使用率
 vTaskGetRunTimeStats((char *)&pcWriteBuffer);
 printf("%s\r\n", pcWriteBuffer);
 根据上面的api接口可以来优先task需要的栈以及cpu的负载情况
